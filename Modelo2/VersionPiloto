import asyncio
import os
import time
import io
from concurrent.futures import ProcessPoolExecutor, ThreadPoolExecutor
from functools import partial

from PIL import Image, ExifTags
from google.cloud import vision_v1
from google.cloud.vision_v1 import types
from rembg import remove

# Configurar el número de hilos del ThreadPoolExecutor
EXECUTOR_THREADS = os.cpu_count() * 2


def get_vision_client():
    return vision_v1.ImageAnnotatorClient()


async def detect_objects(image_content, client, executor):
    loop = asyncio.get_running_loop()
    return await loop.run_in_executor(executor, client.object_localization, types.Image(content=image_content))


async def remove_background_async(input_buffer, executor):
    loop = asyncio.get_running_loop()
    return await loop.run_in_executor(executor, remove, input_buffer)


async def correct_image_orientation_async(img, executor):
    def correct_orientation(imagen):
        orientation_key = None
        for orientation, tag in ExifTags.TAGS.items():
            if tag == 'Orientation':
                orientation_key = orientation
                break

        if orientation_key is None:
            print("No orientation tag found")
            return imagen

        try:
            exif = imagen.getexif()
            if exif is not None:
                exif = dict(exif.items())
                orientation = exif.get(orientation_key)
                if orientation == 3:
                    imagen = imagen.rotate(180, expand=True)
                elif orientation == 6:
                    imagen = imagen.rotate(270, expand=True)
                elif orientation == 8:
                    imagen = imagen.rotate(90, expand=True)
        except Exception as e:
            print(f"Error correcting orientation: {e}")
        return imagen

    loop = asyncio.get_running_loop()
    return await loop.run_in_executor(executor, correct_orientation, img)


async def process_image(image_path, client, output_folder, filename_prefix, i, executor, process_executor):
    with open(image_path, "rb") as image_file:
        content = image_file.read()

    pil_image = Image.open(io.BytesIO(content))

    orientation_task = correct_image_orientation_async(pil_image, executor)
    detection_task = detect_objects(content, client, executor)

    pil_image, response = await asyncio.gather(orientation_task, detection_task)

    if response.localized_object_annotations:
        detected_objects = response.localized_object_annotations
        object_vertices = [vertex for obj in detected_objects for vertex in obj.bounding_poly.normalized_vertices]
        if object_vertices:
            x_coords, y_coords = zip(
                *[(vertex.x * pil_image.width, vertex.y * pil_image.height) for vertex in object_vertices])
            left, top, right, bottom = min(x_coords), min(y_coords), max(x_coords), max(y_coords)

            padding = max(pil_image.width, pil_image.height) * 0.12  # 12% padding
            left = max(0, left - padding)
            top = max(0, top - padding)
            right = min(pil_image.width, right + padding)
            bottom = min(pil_image.height, bottom + padding)

            cropped_image = pil_image.crop((left, top, right, bottom))

            # Redimensionar temporalmente la imagen antes de eliminar el fondo
            original_size = cropped_image.size
            max_size = (800, 800)  # Tamaño máximo para reducir temporalmente
            cropped_image.thumbnail(max_size, Image.LANCZOS)

            image_buffer = io.BytesIO()
            cropped_image.save(image_buffer, format="PNG")
            image_buffer.seek(0)
            transparent_image_buffer = await remove_background_async(image_buffer.read(), process_executor)
            transparent_image = Image.open(io.BytesIO(transparent_image_buffer))

            # Redimensionar la imagen al tamaño original
            transparent_image = transparent_image.resize(original_size, Image.LANCZOS)

            final_image = Image.new("RGB", (940, 1215), "white")
            transparent_image.thumbnail((940, 1215), Image.LANCZOS)
            x_center = (940 - transparent_image.width) // 2
            y_center = (1215 - transparent_image.height) // 2
            final_image.paste(transparent_image, (x_center, y_center), transparent_image)

            await save_adjusted_image_async(final_image, output_folder, filename_prefix, i, executor)


async def save_adjusted_image_async(image, output_folder, filename_prefix, i, executor):
    filename = f"{filename_prefix}{i}.jpeg"
    output_path = os.path.join(output_folder, filename)
    loop = asyncio.get_running_loop()

    save_func = partial(image.save, output_path, format='JPEG', dpi=(72, 72))

    await loop.run_in_executor(executor, save_func)


async def process_images(image_folder, output_folder="prueba", batch_size=10):
    client = get_vision_client()
    os.makedirs(output_folder, exist_ok=True)
    image_paths = [os.path.join(image_folder, filename) for filename in os.listdir(image_folder) if
                   filename.endswith((".jpg", ".jpeg", ".png"))]

    with ThreadPoolExecutor(max_workers=EXECUTOR_THREADS) as executor, ProcessPoolExecutor(
            max_workers=EXECUTOR_THREADS) as process_executor:
        tasks = []
        for i in range(0, len(image_paths), batch_size):
            batch = image_paths[i:i + batch_size]
            for index, path in enumerate(batch):
                task = process_image(path, client, output_folder, "DetectAI", i + index + 1, executor, process_executor)
                tasks.append(task)
        await asyncio.gather(*tasks)


async def main():
    image_folder = "/Users/imartinezt/Downloads/imagesTest/"
    await process_images(image_folder)


if __name__ == "__main__":
    start = time.time()
    asyncio.run(main())
    end = time.time()
    print(f"Se ha tardado {end - start:.2f} segundos")
